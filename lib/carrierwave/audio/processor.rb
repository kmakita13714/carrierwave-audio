require 'ruby-sox'
require 'soxi/wrapper'
require 'fileutils'

module CarrierWave
  module Audio
    class Processor
      DefaultConvertOptions = {
        output_format: :mp3,
        logger: nil
      }
      DefaultWatermarkOptions = {
        output_format: :mp3,
        logger: nil
      }

      # Scope these under Processor so you can catch the ones generated by just this
      # class.
      class RuntimeError < ::RuntimeError;end;
      class ArgumentError < ::ArgumentError;end;

      class << self
        # Convert an audio file at the given filename with the given options.
        #
        # Available options (all optional) are:
        #
        #   :output_format => Output file format
        #
        #     Currently only :mp3 supported
        #     Default is :mp3.
        #
        #   :logger => IOStream to log progress to.
        #
        # Example:
        #   CarrierWave::Audio::Processor.convert("Kickstart My Heart.wav")
        #   CarrierWave::Audio::Processor.generate("Kickstart My Heart.wav", :output_format => :wav)
        #
        def convert(source, options={})
          options = DefaultConvertOptions.merge(options)
          format = sanitized_format(options[:output_format])

          @log = Log.new(options[:logger])
          @log.start!

          ext = File.extname(source)
          input_options = { type: ext.gsub(/\./, '') }
          final_filename = tmp_filename(source: source, format: format)
          @log.timed("\nConverting...") do
            convert_file(
              input_file_path: source, 
              input_options: input_options, 
              output_file_path: final_filename, 
              output_options: output_options_for_format(format)
            )
          end

          @log.done!("Converted audio file '#{final_filename}'")

          final_filename
        end

        # Watermark an audio file at the given filename with the given options.
        #
        # Available options are:
        #
        #   :watermark_file => (REQUIRED) Watermark audio file path
        #
        #   :output_format => (Optional) Output file format
        #
        #     Currently only :mp3 supported
        #     Default is :mp3.
        #
        #   :logger => (Optional) IOStream to log progress to.
        #
        # Example:
        #   CarrierWave::Audio::Processor.watermark("Kickstart My Heart.wav", { watermark_file: "#{Rails.root}/db/watermark.mp3" })
        #
        def watermark(source, options={})
          options = DefaultWatermarkOptions.merge(options)
          format = sanitized_format(options[:output_format])
          watermark_file_path = options[:watermark_file]

          raise ArgumentError.new("No watermark filename given, must be a path to an existing sound file.") unless watermark_file_path
          raise RuntimeError.new("Watermark file '#{watermark_file_path}' not found.") unless File.exist?(watermark_file_path)

          @log = Log.new(options[:logger])
          @log.start!

          ext = File.extname(source)
          input_options = { type: ext.gsub(/\./, '') }
          normalized_filename = tmp_filename(source: source, format: format, prefix: "norm")
          @log.timed("\nNormalizing file to -6dB...") do
            convert_file(
              input_file_path: source, 
              input_options: input_options, 
              output_file_path: normalized_filename, 
              output_options: output_options_for_format(input_options[:type]), 
              fx: { gain: "-n -6" }
            )
          end

          watermark_ext = File.extname(watermark_file_path)
          watermark_options = { type: watermark_ext.gsub(/\./, '') }
          final_filename = tmp_filename(source: source, format: format, prefix: "wtmk")
          @log.timed("\nCombining normalized file and watermark, normalizing final output to 0dB...") do
            combiner = Sox::Cmd.new(combine: :mix)
            combiner.add_input normalized_filename, input_options
            combiner.add_input watermark_file_path, watermark_options
            combiner.set_output final_filename, output_options_for_format(format)
            combiner.set_effects({ trim: "0 =#{Soxi::Wrapper.file(source).seconds}", gain: "-n" })
            combiner.run
          end

          @log.done!("Watermarked audio file '#{final_filename}'")

          final_filename
        end

        private

        # Convert file using options
        def convert_file input_file_path:, input_options:, output_file_path:, output_options:, fx: {}
          converter = Sox::Cmd.new
          converter.add_input input_file_path, input_options
          converter.set_output output_file_path, output_options
          converter.set_effects fx
          converter.run
        end

        def sanitized_format format
          supported_formats = [:mp3, :ogg]
          if supported_formats.include?(format.to_sym)
            format.to_s
          else
            raise ArgumentError.new("Unsupported audio format #{format}. Only conversion to #{supported_formats.to_sentence} allowed.")
          end
        end

        def output_options_for_format format
          shared_options = {
            channels: 2
          }

          if format.to_sym == :mp3
            {
              type: format.to_s,
              rate: 44100,
              compression: 128
            }.merge(shared_options)
          else
            {
              type: format.to_s,
              rate: 44100
            }.merge(shared_options)
          end
        end

        # Generate a temporary filename
        def tmp_filename source:, format:, prefix: nil
          ext = File.extname(source)
          source_filename_without_ext = File.basename(source, ext)
          File.join File.dirname(source), "tmp#{prefix.present? ? '_' + prefix : ''}_#{source_filename_without_ext}_#{Time.now.to_i}.#{format}"
        end

        # A simple class for logging + benchmarking, nice to have good feedback on a
        # long batch operation.
        #
        # There's probably 10,000,000 other bechmarking classes, but writing this was
        # easier than using Google.
        class Log
          attr_accessor :io

          def initialize(io=$stdout)
            @io = io
          end

          # Prints the given message to the log
          def out(msg)
            io.print(msg) if io
          end

          # Prints the given message to the log followed by the most recent benchmark
          # (note that it calls .end! which will stop the benchmark)
          def done!(msg="")
            out "#{msg} (#{self.end!}s)\n"
          end

          # Starts a new benchmark clock and returns the index of the new clock.
          #
          # If .start! is called again before .end! then the time returned will be
          # the elapsed time from the next call to start!, and calling .end! again
          # will return the time from *this* call to start! (that is, the clocks are
          # LIFO)
          def start!
            (@benchmarks ||= []) << Time.now
            @current = @benchmarks.size - 1
          end

          # Returns the elapsed time from the most recently started benchmark clock
          # and ends the benchmark, so that a subsequent call to .end! will return
          # the elapsed time from the previously started benchmark clock.
          def end!
            elapsed = (Time.now - @benchmarks[@current])
            @current -= 1
            elapsed
          end

          # Returns the elapsed time from the benchmark clock w/ the given index (as
          # returned from when .start! was called).
          def time?(index)
            Time.now - @benchmarks[index]
          end

          # Benchmarks the given block, printing out the given message first (if
          # given).
          def timed(message=nil, &block)
            start!
            out(message) if message
            yield
            done!
          end
        end
      end
    end
  end
end
